import os
import sys
import xml.etree.ElementTree as ET
import base64
import tempfile
import subprocess
from datetime import datetime
from multiprocessing.dummy import Pool as ThreadPool

# Constants
DEFAULT_TARGET_FILE = "targets.txt"
TIMESTAMP = datetime.now().strftime('%Y%m%d_%H%M%S')
BASE_FOLDER = "scan_outputs"
THREADS = 10

# Ensure base folders exist
def setup_folders():
    os.makedirs(BASE_FOLDER, exist_ok=True)
    for subfolder in ["testssl_logs", "nikto_logs", "ffuf_logs", "ssh_audit_logs", "hydra_logs", "wafw00f_logs", "nmap"]:
        os.makedirs(os.path.join(BASE_FOLDER, subfolder), exist_ok=True)

# Run shell commands and log output
def run_command(cmd, output_file):
    try:
        with open(output_file, "w") as f:
            subprocess.run(cmd, shell=True, stdout=f, stderr=subprocess.STDOUT, timeout=600)
    except Exception as e:
        with open(output_file, "a") as f:
            f.write(f"\n[!] Error running command: {e}\n")

def run_parallel_scan(cmds, folder, label):
    print(f"[*] Running {label} scans in parallel...")
    pool = ThreadPool(THREADS)
    for cmd, name in cmds:
        outfile = os.path.join(folder, f"{name}_{TIMESTAMP}.txt")
        pool.apply_async(run_command, args=(cmd, outfile))
    pool.close()
    pool.join()

# Step 1: Run full TCP port scan
# Step 2: Extract open ports and run service scan only on those

def run_tcp_port_scan(target_file):
    nmap_output_folder = os.path.join(BASE_FOLDER, "nmap")
    os.makedirs(nmap_output_folder, exist_ok=True)
    output_path = os.path.join(nmap_output_folder, f"nmap_tcp_allports_{TIMESTAMP}")
    cmd = f"nmap -p- -T4 -iL {target_file} -oA {output_path}"
    print(f"[*] Running full TCP port scan...")
    subprocess.run(cmd, shell=True)
    return f"{output_path}.gnmap"

def extract_open_ports_from_gnmap(gnmap_file):
    ip_ports = {}
    try:
        with open(gnmap_file, 'r') as f:
            for line in f:
                if "/open/" in line:
                    parts = line.strip().split()
                    ip = parts[1]
                    port_section = line.split("Ports:")[-1]
                    ports = [entry.split("/")[0] for entry in port_section.strip().split(",") if "/open/" in entry]
                    if ports:
                        ip_ports[ip] = sorted(set(ports))
    except Exception as e:
        print(f"[!] Failed to parse GNMAP file: {e}")
        sys.exit(1)
    return ip_ports

def run_nmap_service_scan(ip_ports):
    nmap_output_folder = os.path.join(BASE_FOLDER, "nmap")
    service_xml = os.path.join(nmap_output_folder, f"nmap_service_scan_{TIMESTAMP}.xml")
    with open(os.path.join(nmap_output_folder, f"targets_with_ports_{TIMESTAMP}.txt"), "w") as f:
        for ip, ports in ip_ports.items():
            port_str = ",".join(ports)
            f.write(f"{ip} -p{port_str}\n")
    cmd = f"nmap -sS -sV -T4 -oX {service_xml} " + " ".join([f"-p{','.join(ports)} {ip}" for ip, ports in ip_ports.items()])
    print(f"[*] Running Nmap service scan on discovered open ports...")
    subprocess.run(cmd, shell=True)
    return service_xml

# Parse Nmap XML to get services per IP
def parse_nmap_xml(nmap_xml_file):
    targets = {"http": [], "https": [], "ssh": [], "ssl": []}
    try:
        tree = ET.parse(nmap_xml_file)
        root = tree.getroot()

        for host in root.findall("host"):
            ip = None
            address = host.find("address")
            if address is not None and address.get("addrtype") == "ipv4":
                ip = address.get("addr")
            if not ip:
                continue

            ports = host.find("ports")
            if ports is None:
                continue

            for port in ports.findall("port"):
                portid = port.get("portid")
                state = port.find("state").get("state")
                service = port.find("service")
                name = service.get("name") if service is not None else ""
                if state != "open":
                    continue

                proto = f"{ip}:{portid}"

                if name in ["http", "http-alt"]:
                    targets["http"].append(proto)
                elif name in ["https", "https-alt", "ssl/http", "ssl"]:
                    targets["https"].append(proto)
                    targets["ssl"].append(proto)
                elif name == "ssh":
                    targets["ssh"].append(proto)
                elif "ssl" in name or "https" in name:
                    targets["ssl"].append(proto)

    except Exception as e:
        print(f"[!] Failed to parse Nmap XML: {e}")
        sys.exit(1)

    return targets

# Decode base64 credentials
def decode_creds(base64_file):
    if not os.path.isfile(base64_file):
        print(f"[!] Base64 credentials file not found: {base64_file}")
        sys.exit(1)

    combos = []
    with open(base64_file, "r") as f:
        for line in f:
            try:
                decoded = base64.b64decode(line.strip()).decode()
                if ":" in decoded:
                    combos.append(decoded)
            except Exception as e:
                print(f"[!] Skipping invalid base64 line: {line.strip()} ({e})")
    return combos

# Prepare and run tools
def prepare_and_run_scans(targets):
    if not any(targets.values()):
        print("[!] No open ports found for any scan, exiting.")
        sys.exit(1)

    if targets["ssl"]:
        testssl_cmds = [(f"testssl.sh --warnings batch {ip_port}", ip_port.replace(":", "_")) for ip_port in targets["ssl"]]
        run_parallel_scan(testssl_cmds, os.path.join(BASE_FOLDER, "testssl_logs"), "testssl")

    if targets["http"] or targets["https"]:
        nikto_cmds, ffuf_cmds, wafw00f_cmds = [], [], []
        for ip_port in targets["http"] + targets["https"]:
            ip, port = ip_port.split(":")
            url = f"http://{ip}:{port}"
            nikto_cmd = f"nikto -h {url}"
            ffuf_cmd = f"ffuf -u {url}/FUZZ -w /usr/share/wordlists/dirb/common.txt -mc all -of json -o {BASE_FOLDER}/ffuf_logs/{ip}_{port}_{TIMESTAMP}.json"
            wafw00f_cmd = f"wafw00f {url}"
            nikto_cmds.append((nikto_cmd, f"{ip}_{port}"))
            ffuf_cmds.append((ffuf_cmd, f"{ip}_{port}"))
            wafw00f_cmds.append((wafw00f_cmd, f"{ip}_{port}"))

        run_parallel_scan(nikto_cmds, os.path.join(BASE_FOLDER, "nikto_logs"), "nikto")
        run_parallel_scan(ffuf_cmds, os.path.join(BASE_FOLDER, "ffuf_logs"), "ffuf")
        run_parallel_scan(wafw00f_cmds, os.path.join(BASE_FOLDER, "wafw00f_logs"), "wafw00f")

    if targets["ssh"]:
        ssh_audit_cmds = [(f"ssh-audit {ip} -p {port}", f"{ip}_{port}") for ip_port in targets["ssh"] for ip, port in [ip_port.split(":")]]
        run_parallel_scan(ssh_audit_cmds, os.path.join(BASE_FOLDER, "ssh_audit_logs"), "ssh-audit")

        base64_creds_file = "creds.txt"
        combos = decode_creds(base64_creds_file)
        with tempfile.NamedTemporaryFile(mode="w+", delete=False) as tmp:
            for combo in combos:
                tmp.write(combo + "\n")
            combo_file_path = tmp.name

        hydra_cmds = [(f"hydra -C {combo_file_path} -s {port} {ip} ssh", f"{ip}_{port}") for ip_port in targets["ssh"] for ip, port in [ip_port.split(":")]]
        run_parallel_scan(hydra_cmds, os.path.join(BASE_FOLDER, "hydra_logs"), "hydra")

def main():
    print("=== Automated Pentest Scanner (Nmap XML-based) ===")
    setup_folders()

    target_file = input(f"Enter target file path [default: {DEFAULT_TARGET_FILE}]: ").strip()
    if not target_file:
        target_file = DEFAULT_TARGET_FILE

    if not os.path.isfile(target_file):
        print(f"[!] Target file '{target_file}' not found.")
        sys.exit(1)

    mode = input("Run full scan? (yes/no): ").strip().lower()
    if mode not in ["yes", "no"]:
        print("[!] Invalid choice.")
        sys.exit(1)

    gnmap_output = run_tcp_port_scan(target_file)
    ip_ports = extract_open_ports_from_gnmap(gnmap_output)
    xml_output = run_nmap_service_scan(ip_ports)
    targets = parse_nmap_xml(xml_output)

    if mode == "yes":
        prepare_and_run_scans(targets)
    else:
        print("[*] Only Nmap scans completed. Other scans skipped.")

if __name__ == "__main__":
    main()
